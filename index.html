<!DOCTYPE html>
<html>
<head>
	<title>US Wildfires</title>
	<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
	<script src="http://d3js.org/topojson.v1.min.js"></script>
	<script src="https://d3js.org/d3-time.v1.min.js"></script>
	<script src="https://d3js.org/d3-time-format.v2.min.js"></script>
	<script src="d3.legend.js"></script>

	<style type="text/css">
	.feature {
		fill: none;
		stroke: grey;
		stroke-width: 1px;
		stroke-linejoin: round;
	}
	.mesh {
		fill: none;
		stroke: darkgrey;
		stroke-width: 2px;
		stroke-linejoin: round;
	}
	h1 {
		font-family: sans-serif;
	}
	.sliderDiv {
		width: 950px;
		height: 25px;
	}
	.slider {
		width: 900px !important;
	}
	text {
		font-family: sans-serif;
	}
	.chartTitle {
		font-size:18px;
	}
	.xaxis path,
	.yaxis path {
		fill: #777;
		stroke-opacity: 0.5;
	}

	.legend rect {
	  fill:white;
	  stroke:black;
	  opacity:0.8;
	}

	#tooltip {
		position: absolute;
		width: 200;
		height: auto;
		padding: 10px;
		background-color: white;
		-webkit-border-radius: 10px;
		-mox-border-radius: 10px;
		border-radius: 10px;
		-webkit-box-shadow: 4px 4px 10px rgba(0, 0, 0, 0.4);
		-mox-box-shadow: 4px 4px 10px rgba(0, 0, 0, 0.4);
		box-shadow: 4px 4px 10px rgba(0, 0, 0, 0.4);
		pointer-events: none;
		/* white-space: pre-line; */
		word-wrap: break-word;
	}

	#tooltip.hidden {
		display: none;
	}

	#tooltip p{
		margin: 0;
		font-family: sans-serif;
		font-size: 16px;
		line-height: 20px;
	}
	</style>
</head>
<body>
	<h1 id="title">US Wildfires</h1>
	<div class="mainMap"></div><br/>
	<div class="sliderDiv"></div>
	<div class="weatherChart"></div>
	<div class="dataChart"></div>
	<div class="legend"></div>
	<div id="tooltip" class="hidden">
			<p><strong>Key Info</strong></p>
			<p><span id="value">100</span></p>
	<script type="text/javascript">

	var map_width = 950,
		map_height = 550;

	// Maps fire class to a radius size
	var firesize_class_radius = { "A": 3,
								  "B": 5,
								  "C": 7,
								  "D": 9,
								  "E": 11,
								  "F": 13,
								  "G": 15 };

	// Define possible fire causes (to use for colors)
	var fire_causes_color_map = { "Debris Burning": "#e6194b",
					              "Miscellaneous": "#3cb44b",
					              "Arson": "#ffe119",
					              "Lightning": "#0082c8",
					              "Missing/Undefined": "#f58231",
					              "Equipment Use": "#911eb4",
					              "Campfire": "#46f0f0",
					              "Children": "#f032e6",
					              "Smoking": "#d2f53c",
					              "Railroad": "#fabebe",
					              "Powerline": "#008080",
					              "Fireworks": "#e6beff",
					              "Structure": "#aa6e28"};

	// set projection
	var projection = d3.geo.albers();

	// create path variable
	var path = d3.geo.path().projection(projection);

	var curr_zoom_translate;
	var curr_zoom_scale;
	var curr_year = 2000;

	d3.json("data/us.json", function(error, topo) {
		d3.csv("data/wildfires_10k_sample.csv", function(error, data) {
			d3.csv("data/weather/combined/long/all_years_long.csv", function(error, weather_data) {
				console.log(data);
				console.log(weather_data);

				// build id --> latitude/latittude map
				var lat_long_year_map = {};
				for (var i = 0; i < data.length; i++) {
					var d = data[i];
					lat_long_year_map[String(d.OBJECT_ID)] = [d.LATITUDE, d.LONGITUDE, d.FIRE_YEAR];
				}

				// create svg variable
				var svg = d3.select(".mainMap").append("svg")
								.attr("width", map_width)
								.attr("height", map_height);

				var g = svg.append("g");

				// Add slider
				d3.select(".sliderDiv").append("text").text("Year: ");

				var slider =  d3.select(".sliderDiv").append("input")
					.attr("class", "slider")
					.attr("type", "range")
					.attr("id", "yearSlider")
					.attr("min", 2000)
					.attr("max", 2015)
					.on("input", function() {
						curr_year = parseInt(this.value);
						drawPoints(data, weather_data, curr_year);
						findViewportLatLong(data, lat_long_year_map, curr_zoom_translate, curr_zoom_scale, curr_year);
						updateTitle(curr_year);
					});

				drawMap(data, topo, path, projection, lat_long_year_map, curr_year);
				drawPoints(data, weather_data, curr_year);
				updateTitle(curr_year);
			});
		});

		var drawMap = function(data, topo, path, projection, lat_long_year_map, curr_year) {
		  	states = topojson.feature(topo, topo.objects.states).features;

		  	var svg = d3.select(".mainMap").select("svg");

			var g = svg.select("g");

			// add states from topojson
			g.selectAll("path")
				.data(states).enter()
				.append("path")
				.attr("class", "feature")
				.style("fill", "white")
				.attr("d", path);

			// put border around states
			g.append("path")
				.datum(topojson.mesh(topo, topo.objects.states, function(a, b) { return a !== b; }))
				.attr("class", "mesh")
				.attr("d", path);

			// zooming and panning
			var zoom = d3.behavior.zoom()
				.on("zoom",function(){
					curr_zoom_translate = d3.event.translate;
					curr_zoom_scale = d3.event.scale;
					zoomTo(curr_zoom_translate, curr_zoom_scale);
					if (curr_zoom_translate != null && curr_zoom_scale != null) {
						findViewportLatLong(data, lat_long_year_map, curr_zoom_translate, curr_zoom_scale, curr_year);
					}
				});

			var zoomTo = function(translate, scale) {
				g.attr("transform","translate("+ translate.join(",")+")scale("+scale+")");
			};

			d3.select(".mainMap").select("svg").call(zoom);
		}

		var drawPoints = function(data, weather_data, year) {
			var filtered_data = data.filter(function(d) {
				return d.FIRE_YEAR == year;
			});

			var g = d3.select(".mainMap").select("svg").select("g");
			// var inner = g.append("g")

			// Remove all previously drawn circles
			g.selectAll("circle").remove();
			g.selectAll("g").remove();

			// add circles to svg
			g.selectAll("circle")
				.data(filtered_data)
				.enter()
				.append("circle")
				.attr("id", function (d) { return d.OBJECT_ID; })
				.attr("class", function (d) { return "p" + d.OBJECT_ID; })
				.attr("cx", function (d) { return projection([d.LONGITUDE, d.LATITUDE])[0]; }) 	// Sets location of the wildfire datapoint
				.attr("cy", function (d) { return projection([d.LONGITUDE, d.LATITUDE])[1]; }) 	// Sets location of the wildfire datapoint
				.attr("r", function (d) { return firesize_class_radius[d.FIRE_SIZE_CLASS]; })  	// Sets radius of the wildfire datapoint
				.attr("fill", function(d) { return fire_causes_color_map[d.STAT_CAUSE_DESCR]; })// Sets fill of the wildfire datapoint
				.attr("data-legend", function(d) {return d.STAT_CAUSE_DESCR})
				.on("mouseover",function(d){
					var id = d3.select(this).attr("id");
					//drawWeatherChart(weather_data, id);

					// Tooltip on mouseover
					var filtered_data = data.filter(function(d){
						return d.OBJECT_ID == id;
					});

					var lat = filtered_data[0].LATITUDE;
					var long = filtered_data[0].LONGITUDE;

					d3.select("#tooltip")
						.style("left", d3.select(this).attr("cx") + "px")
						.style("top", d3.select(this).attr("cy") + "px")
						.select("#value")
						.html("Fire Name: " + d.FIRE_NAME + "<br/>" + "Year: " + d.FIRE_YEAR + "<br/>" + "Cause: " + d.STAT_CAUSE_DESCR)

					d3.select("#tooltip").classed("hidden", false);
				})
				.on("mouseout", function() {
					d3.select("#tooltip").classed("hidden",true);
				});

				// Create Legend
				var legend = g.append("g")
					.attr("class","legend")
					// .attr("transform","translate(" + map_width - 1 + "," + "50)")
					.attr("transform","translate(20,375)")
					.style("font-size","12px")
					.call(d3.legend)

				setTimeout(function() {
					legend
						.style("font-size","12px")
						.attr("data-style-padding",10)
						.call(d3.legend)
						},1000)
		}

		// Finds the min and max lat and longs of the data points in the viewport
		var findViewportLatLong = function(data, lat_long_year_map, translate, scale, curr_year) {	
			var min_lat = Number.MAX_SAFE_INTEGER;
			var max_lat = Number.MIN_SAFE_INTEGER;
			var min_long = Number.MAX_SAFE_INTEGER;
			var max_long = Number.MIN_SAFE_INTEGER;

			var count = 0;

			var cs = d3.selectAll("circle")[0];
			for (var i = 0; i < cs.length; i++) {
				var c = cs[i];

				if (c != null && c.attributes != null && c.attributes.id != null) {
					count++;
					var id = c.attributes.id.value;
					var cx = c.attributes.cx.value;
					var cy = c.attributes.cy.value;
					var transformed_cx = (cx * scale) + translate[0];
					var transformed_cy = (cy * scale) + translate[1];
					var lat = lat_long_year_map[id][0];
					var long = lat_long_year_map[id][1];
					var year = lat_long_year_map[id][2];
					
					// Check if circle is in the viewport
					if (transformed_cx > 0 && transformed_cy > 0 && transformed_cx <= map_width && transformed_cy <= map_height && year == curr_year) {
						// Check if the circle is the max or min lat/long so far. If so, update the max/min lat/long
						if (lat < min_lat) { min_lat = lat; }
						if (lat > max_lat) { max_lat = lat; }
						if (lat < min_long) { min_long = long; }
						if (lat > max_long) { max_long = long; }
						count++;
					}
				}
			}

			ret_arr = [ min_lat, max_lat, min_long, max_long ];
			console.log(ret_arr);
			console.log(count);
			return ret_arr;
		}

		// To do: Mohammad to draw weather chart here
		var drawWeatherChart = function (weather_data, id) {
			// This is the id of the data point

			var formatDate = d3.timeFormat("%Y-%m-%d");
			var parseDate = d3.timeParse("%Y-%m-%d");

			var filtered_weather_data = weather_data.filter(function(d){
				return d.FIRE_ID == id;
			});

			filtered_weather_data.sort(function(x, y){
   				return d3.ascending(parseDate(x.OBS_DATE), parseDate(y.OBS_DATE));
			})

			// Set width of all chart components
			var width_weatherchart = 950;
			var height_data = 300;
			var height_xaxis = 50;
			var margin_weatherChart = {top: 50, right: 50, bottom: 20, left: 100};

			var width_data = width_weatherchart - margin_weatherChart.right - margin_weatherChart.left;
			var width_xaxis = width_data;

			// Set width and height of the weatherChart
			var width_weatherchart = width_data + margin_weatherChart.left + margin_weatherChart.right;
			var height_weatherchart = height_data + height_xaxis + margin_weatherChart.top + margin_weatherChart.bottom;

			var min_obs_date = d3.min(filtered_weather_data, function(d) { return parseDate(d.OBS_DATE); });
			var max_obs_date = d3.max(filtered_weather_data, function(d) { return parseDate(d.OBS_DATE); });

			var min_prcp = d3.min(filtered_weather_data, function(d) { return d.PRCP; });
			var max_prcp = d3.max(filtered_weather_data, function(d) { return d.PRCP; });

			x_scale_prcp = d3.scale.linear()
			  .domain([min_obs_date, max_obs_date])
			  .range([margin_weatherChart.left, margin_weatherChart.left + width_data]);

			y_scale_prcp = d3.scale.linear()
			  .domain([0, 100]) // 0% to 100% percipitation
			  .range([height_data + margin_weatherChart.top, margin_weatherChart.top]);

			var x_axis_prcp = d3.svg.axis()
				.scale(x_scale_prcp)
				.orient("bottom")
				.ticks(10)
				.tickFormat(formatDate)
				;

			var y_axis_prcp = d3.svg.axis()
				.scale(y_scale_prcp)
				.orient("left")
				.ticks(10)
				;

			// Remove previously drawn weatherChart
			d3.select(".weatherChart").select("svg").remove();

			// Draw weatherChart
			var svg = d3.select(".weatherChart").append("svg")
				.attr("width", width_weatherchart)
				.attr("height", height_weatherchart);

			// Draw x-axis
			svg.append("g")
			  .attr("class", "xaxis")
			  .attr("width", width_xaxis)
			  .attr("height", height_xaxis)
			  .attr("transform", "translate(0," + (margin_weatherChart.top + height_data) + ")")
			  .call(x_axis_prcp);

			// Draw y-axis label
			svg.append("g").append("text")
  				.text("Date")
  				.attr("transform", "translate("+ ((margin_weatherChart.left + width_xaxis)/2) +", " + (margin_weatherChart.top + height_data + 40) +")");

			// Draw y-axis
			svg.append("g")
			  .attr("class", "yaxis")
			  .attr("width", 100)
			  .attr("height", 50)
			  .attr("transform", "translate(" + (margin_weatherChart.left) + ",0)")
			  .call(y_axis_prcp);

			// Draw y-axis label
			svg.append("g").append("text")
  				.text("% Percipitation")
  				.attr("transform", "translate(0, " + (margin_weatherChart.top - 15) +")");

			// Draw chart title
			svg.append("g").append("text")
				.attr("class", "chartTitle")
  				.text("Percent Percipitation During the Incident")
  				.attr("transform", "translate("+ ((margin_weatherChart.left + width_xaxis)/2 - 100) +", " + (margin_weatherChart.top - 20) +")");

			// Draw chart line
			var valueline = d3.svg.line()
				.x(function(d) { return x_scale_prcp(parseDate(d.OBS_DATE)); })
				.y(function(d) { return y_scale_prcp(d.PRCP); })
			;

			var g = svg.append("g");

			// Remove all previously drawn line
			g.selectAll("path").remove();

			// add line to g
			g.append("path")
				.attr("class", "line")
				.attr("d", valueline(filtered_weather_data))
				.attr("fill", "none")
  				.attr("stroke-width", "2")
  				.attr("stroke", "steelblue")
  				;
		}

		var updateTitle = function(year){
			d3.select("#title").text(function() { return "US Wildfires - " + year;});
		}

	});

	</script>
</body>
</html>
